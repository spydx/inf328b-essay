
@online{ratnakumar_brief_nodate,
	title = {A brief F\# exploration},
	url = {https://notes.srid.ca/fsharp-exploration},
	abstract = {I have been writing full-stack web apps in Haskell using functional reactive programming (Reflex-{FRP}) for 3 years now. Curiosity stuck me as to find out what the {FP} languages other than Haskell had to offer in this area.},
	titleaddon = {Sridhar Ratnakumar},
	author = {Ratnakumar, Sridhar},
	urldate = {2021-04-09},
	keywords = {f\#, presentation},
	file = {Snapshot:/Users/kenneth/Zotero/storage/E6TTNNEA/fsharp-exploration.html:text/html}
}

@online{noauthor_bolero_nodate,
	title = {Bolero: F\# in {WebAssembly}},
	url = {https://fsbolero.io/},
	urldate = {2021-04-09},
	file = {Bolero\: F# in WebAssembly:/Users/kenneth/Zotero/storage/AQU79GGQ/fsbolero.io.html:text/html}
}

@article{syme_early_2020,
	title = {The early history of F\#},
	volume = {4},
	issn = {2475-1421},
	doi = {10.1145/3386325},
	abstract = {This paper describes the genesis and early history of the F\# programming language. I start with the origins of strongly-typed functional programming ({FP}) in the 1970s, 80s and 90s. During the same period, Microsoft was founded and grew to dominate the software industry. In 1997, as a response to Java, Microsoft initiated internal projects which eventually became the .{NET} programming framework and the C\# language. From 1997 the worlds of academic functional programming and industry combined at Microsoft Research, Cambridge. The researchers engaged with the company through Project 7, the initial effort to bring multiple languages to .{NET}, leading to the initiation of .{NET} Generics in 1998 and F\# in 2002. F\# was one of several responses by advocates of strongly-typed functional programming to the "object-oriented tidal wave" of the mid-1990s. The development of the core features of F\# 1.0 happened from 2004-2007, and I describe the decision-making process that led to the "productization" of F\# by Microsoft in 2007-10 and the release of F\# 2.0. The origins of F\#'s characteristic features are covered: object programming, quotations, statically resolved type parameters, active patterns, computation expressions, async, units-of-measure and type providers. I describe key developments in F\# since 2010, including F\# 3.0-4.5, and its evolution as an open source, cross-platform language with multiple delivery channels. I conclude by examining some uses of F\# and the influence F\# has had on other languages so far.},
	pages = {1--58},
	issue = {{HOPL}},
	journaltitle = {Proceedings of {ACM} on programming languages},
	author = {Syme, Don},
	date = {2020},
	note = {Publisher: {ACM}},
	keywords = {f\#, Pattern Matching ; Functional Programming ; Asynchronous Programming ; Programming Languages ; Type Providers ; Dimensions ; Object-oriented Programming ; Units of Measure, don syme, early history},
	file = {Full Text:/Users/kenneth/Zotero/storage/5HAI9WBS/Syme - 2020 - The early history of F.pdf:application/pdf}
}

@inreference{noauthor_don_2021,
	title = {Don Syme},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Don_Syme&oldid=1003588951},
	abstract = {Don Syme is an Australian computer scientist and a Principal Researcher at Microsoft Research, Cambridge, U.K. He is the designer and architect of the F\# programming language, described by a reporter as being regarded as "the most original new face in computer languages since Bjarne Stroustrup developed C++ in the early 1980s."Earlier, Syme created  generics in the .{NET} Common Language Runtime, including the initial design of generics for the C\# programming language, along with others including Andrew Kennedy and later Anders Hejlsberg.  Kennedy, Syme and Dachuan Yu also formalized this widely used system.He holds a Ph.D. from the University of Cambridge, and is a member of the {WG}2.8 working group on functional programming. He is a co-author of the book Expert F\# 3.0.In the past he also worked on formal specification, interactive proof, automated verification and proof description languages.In 2015, he was honored with a Silver Medal from the Royal Academy of Engineering.},
	booktitle = {Wikipedia},
	urldate = {2021-04-21},
	date = {2021-01-29},
	langid = {english},
	note = {Page Version {ID}: 1003588951},
	keywords = {don syme, author},
	file = {Snapshot:/Users/kenneth/Zotero/storage/HAKJYFTJ/index.html:text/html}
}

@online{noauthor_hopl_nodate,
	title = {{HOPL} {IV}},
	url = {https://hopl4.sigplan.org/},
	abstract = {{NEW}! (13 Sep 2020)  {HOPL} {IV} will be virtual, co-located with {PLDI} 2021 
Since {HOPL} {IV} was postponed from its originally planned dates in June 2020, we have worked with {SIGPLAN} to co-locate {HOPL} {IV} with {PLDI} 2021. However, because of the continuing {COVID}-19 (coronavirus) situation, {SIGPLAN} has now determined that there will not be a physical meeting for {HOPL} or {PLDI} in June 2021; both conferences will be virtual, held online. 
{HOPL} {IV} will be held Sunday, June 20, through Tuesday, June 22, 2021. The main {PLDI} conference will be Wednesday, June 23, through Friday, June 25. For othe ...},
	urldate = {2021-04-21},
	keywords = {hopl iv},
	file = {Snapshot:/Users/kenneth/Zotero/storage/SLSHUZ7U/hopl4.sigplan.org.html:text/html}
}

@online{noauthor_programmeringssprak_nodate,
	title = {Programmeringsspråk / Programming Languages},
	url = {https://www.uib.no/en/course/INF222},
	titleaddon = {University of Bergen},
	urldate = {2021-04-21},
	langid = {english},
	keywords = {inf122},
	file = {Snapshot:/Users/kenneth/Zotero/storage/3SVWUKYC/INF222.html:text/html}
}

@inreference{noauthor_hindleymilner_2021,
	title = {Hindley–Milner type system},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Hindley%E2%80%93Milner_type_system&oldid=1016004296},
	abstract = {A Hindley–Milner ({HM}) type system is a classical type system for the lambda calculus with parametric polymorphism. It is also known as Damas–Milner or Damas–Hindley–Milner. It was first described by J. Roger Hindley and later rediscovered by Robin Milner. Luis Damas contributed a close formal analysis and proof of the method in his {PhD} thesis.Among {HM}'s more notable properties are its completeness and its ability to infer the most general type of a given program without programmer-supplied type annotations or other hints. Algorithm W is an efficient type inference method in practice, and has been successfully applied on large code bases, although it has a high theoretical complexity. {HM} is preferably used for functional languages. It was first implemented as part of the type system of the programming language {ML}. Since then, {HM} has been extended in various ways, most notably with type class constraints like those in Haskell.},
	booktitle = {Wikipedia},
	urldate = {2021-04-21},
	date = {2021-04-04},
	langid = {english},
	note = {Page Version {ID}: 1016004296},
	keywords = {hindley-milner},
	file = {Snapshot:/Users/kenneth/Zotero/storage/8VUKFVSX/index.html:text/html}
}

@online{noauthor_funksjonell_nodate,
	title = {Funksjonell programmering / Functional Programming},
	url = {https://www.uib.no/en/course/INF122},
	titleaddon = {University of Bergen},
	urldate = {2021-04-21},
	langid = {english},
	keywords = {inf122},
	file = {Snapshot:/Users/kenneth/Zotero/storage/684ZRNAG/INF122.html:text/html}
}

@article{wadler_why_1998,
	title = {Why no one uses functional languages},
	volume = {33},
	issn = {0362-1340},
	doi = {10.1145/286385.286387},
	pages = {23--27},
	number = {8},
	journaltitle = {{SIGPLAN} notices},
	author = {Wadler, Philip},
	date = {1998},
	note = {Place: New York, {NY}
Publisher: {ACM}},
	keywords = {Applied sciences ; Software ; Exact sciences and technology ; Language processing and microprogramming ; Computer science; control theory; systems ; Software engineering, fp, no one uses, wadler}
}

@article{syme_ilx_2001,
	title = {{ILX}: Extending the .{NET} Common {IL} for Functional Language Interoperability},
	volume = {59},
	issn = {1571-0661},
	url = {https://www.sciencedirect.com/science/article/pii/S1571066105804530},
	doi = {10.1016/S1571-0661(05)80453-0},
	series = {{BABEL}'01, First International Workshop on Multi-Language Infrastructure and Interoperability (Satellite Event of {PLI} 2001)},
	shorttitle = {{ILX}},
	abstract = {This paper describes several extensions to the .{NET} Common Intermediary Language ({CIL}), each of which is designed to enable easier implementation of typed high-level programming languages on the .{NET} platform, and to promote closer integration and interoperability between these languages. In particular we aim for easier interoperability between components whose interfaces are expressed using function types, discriminated unions and parametric polymorphism, regardless of the languages in which these components are implemented. We show that it is possible to add these constructs to an existing, “real world” intermediary language and that this allows corresponding subsets of constructs to be compiled uniformly, which in turn will allow programmers to use these constructs seamlessly between different languages. In this paper we discuss the motivations for our extensions, which are together called Extended {IL} ({ILX}), and describe them via examples. In this setting, many of the traditional responsibilities of the backend of a compiler must be moved to {ILX} and the execution environment, in particular those related to representation choices and low-level optimizations. We have modified a Haskell compiler to generate this language, and have implemented an assembler that translates the extensions to regular or polymorphic {CIL} code. I am very grateful to Nick Benton, Cedric Fournet, Andrew Kennedy, Andy Gordon, Simon Peyton Jones, Claudio Russo, Reuben Thomas, Andrew Tolmach and the anonymous referees for their help and advice with this work.},
	pages = {53--72},
	number = {1},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	shortjournal = {Electronic Notes in Theoretical Computer Science},
	author = {Syme, Don},
	urldate = {2021-04-21},
	date = {2001-11-01},
	langid = {english},
	keywords = {.net generics, generics, ilx},
	file = {ScienceDirect Full Text PDF:/Users/kenneth/Zotero/storage/FML93EXX/Syme - 2001 - ILX Extending the .NET Common IL for Functional L.pdf:application/pdf;ScienceDirect Snapshot:/Users/kenneth/Zotero/storage/TD4G8VB2/S1571066105804530.html:text/html}
}

@online{noauthor_ionide_nodate,
	title = {Ionide},
	url = {https://ionide.io/},
	urldate = {2021-04-21},
	keywords = {ionide},
	file = {Ionide:/Users/kenneth/Zotero/storage/4QUJ447C/ionide.io.html:text/html}
}

@inproceedings{hudak_history_2007,
	title = {A history of Haskell: being lazy with class},
	isbn = {978-1-59593-766-7},
	doi = {10.1145/1238844.1238856},
	series = {{HOPL} {III}},
	shorttitle = {A history of Haskell},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	pages = {12--1--12--55},
	publisher = {{ACM}},
	author = {Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
	date = {2007},
	keywords = {haskell, hopl3}
}

@misc{kennedy_types_nodate,
	title = {Types for Units-of-Measure: Theory and Practice},
	shorttitle = {Types for Units-of-Measure},
	abstract = {Units-of-measure are to science what types are to programming. In science and engineering, dimensional and unit consistency provides a first check on the correctness of an equation or formula, just as in programming the validation of a program by the type-checker eliminates one possible reason for failure.},
	publisher = {Springer Berlin Heidelberg},
	author = {Kennedy, Andrew},
	doi = {10.1007/978-3-642-17685-2_8},
	note = {{ISBN}: 9783642176845
{ISSN}: 0302-9743
Pages: 268–305
Place: Berlin, Heidelberg
Series: Lecture Notes in Computer Science},
	keywords = {f\#, Inference Algorithm ; Equational Theory ; Type System ; Type Inference ; Type Scheme, units-of-measure}
}

@online{dmacqueen_standard_nodate,
	title = {Standard {ML} History},
	url = {https://smlfamily.github.io/history/},
	author = {dmacqueen},
	urldate = {2021-04-21},
	keywords = {family, sml},
	file = {Standard ML History:/Users/kenneth/Zotero/storage/ZRFEAVGR/history.html:text/html}
}

@online{noauthor_history_nodate,
	title = {A History of {OCaml} – {OCaml}},
	url = {https://ocaml.org/learn/history.html},
	urldate = {2021-04-21},
	keywords = {ocaml},
	file = {A History of OCaml – OCaml:/Users/kenneth/Zotero/storage/M928AZG6/history.html:text/html}
}

@online{carter_get_nodate,
	title = {Get started with F\#},
	url = {https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/},
	abstract = {Find out how to get started with the F\# programming language.},
	author = {Carter, Phillip},
	urldate = {2021-04-23},
	langid = {english},
	keywords = {getting started},
	file = {Snapshot:/Users/kenneth/Zotero/storage/HLK6ZSVH/get-started.html:text/html}
}

@online{carter_what_nodate,
	title = {What is F\#},
	url = {https://docs.microsoft.com/en-us/dotnet/fsharp/what-is-fsharp},
	abstract = {Learn about what the F\# programming language is and what F\# programming is like. Learn about rich data types, functions, and how they fit together.},
	author = {Carter, Phillip},
	urldate = {2021-04-23},
	langid = {english},
	file = {Snapshot:/Users/kenneth/Zotero/storage/2CAMNIHA/what-is-fsharp.html:text/html}
}

@online{microsoft_visual_nodate,
	title = {Visual Studio Code - Code Editing. Redefined},
	url = {https://code.visualstudio.com/},
	abstract = {Visual Studio Code is a code editor redefined and optimized for building and debugging modern web and cloud applications.  Visual Studio Code is free and available on your favorite platform - Linux, {macOS}, and Windows.},
	author = {Microsoft},
	urldate = {2021-04-25},
	langid = {english},
	keywords = {vscode},
	file = {Snapshot:/Users/kenneth/Zotero/storage/PCD4574E/code.visualstudio.com.html:text/html}
}

@online{jetbrains_rider_nodate,
	title = {Rider: The Cross-Platform .{NET} {IDE} from {JetBrains}},
	url = {https://www.jetbrains.com/rider/},
	shorttitle = {Rider},
	abstract = {Develop .{NET}, {ASP}.{NET}, .{NET} Core, Xamarin or Unity applications on Windows, Mac, Linux},
	titleaddon = {{JetBrains}},
	author = {Jetbrains},
	urldate = {2021-04-25},
	langid = {english},
	keywords = {ide, rider},
	file = {Snapshot:/Users/kenneth/Zotero/storage/LSKSG46Q/rider.html:text/html}
}

@online{carter_tour_nodate,
	title = {Tour of F\#},
	url = {https://docs.microsoft.com/en-us/dotnet/fsharp/tour},
	abstract = {Examine some of the key features of the F\# programming language in this tour with code samples.},
	author = {Carter, Phillip},
	urldate = {2021-04-25},
	langid = {english},
	file = {Snapshot:/Users/kenneth/Zotero/storage/5GLUNSRR/tour.html:text/html}
}

@online{dykstra_net_nodate,
	title = {.{NET} {SDK} overview},
	url = {https://docs.microsoft.com/en-us/dotnet/core/sdk},
	abstract = {Find out about the .{NET} {SDK}, which is a set of libraries and tools used to create .{NET} projects.},
	author = {Dykstra, Tom},
	urldate = {2021-04-25},
	langid = {english},
	keywords = {.net, sdk},
	file = {Snapshot:/Users/kenneth/Zotero/storage/E685LTPQ/sdk.html:text/html}
}

@online{noauthor_ocaml_nodate,
	title = {{OCaml} – {OCaml}},
	url = {https://ocaml.org/},
	urldate = {2021-04-25},
	keywords = {ocaml},
	file = {OCaml – OCaml:/Users/kenneth/Zotero/storage/LNT34PU8/ocaml.org.html:text/html}
}

@online{carter_units_nodate,
	title = {Units of Measure - F\#},
	url = {https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/units-of-measure},
	abstract = {Learn how floating point and signed integer values in F\# can have associated units of measure, which are typically used to indicate length, volume, and mass.},
	author = {Carter, Phillip},
	urldate = {2021-04-25},
	langid = {english},
	keywords = {units-of-measure},
	file = {Snapshot:/Users/kenneth/Zotero/storage/X8B8CWJT/units-of-measure.html:text/html}
}

@online{carter_active_nodate,
	title = {Active Patterns - F\#},
	url = {https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns},
	abstract = {Learn how to use active patterns to define named partitions that subdivide input data in the F\# programming language.},
	author = {Carter, Phillip},
	urldate = {2021-04-25},
	langid = {english},
	keywords = {active patterns, f\#},
	file = {Snapshot:/Users/kenneth/Zotero/storage/GQD7QDI9/active-patterns.html:text/html}
}

@online{carter_code_nodate,
	title = {Code Quotations - F\#},
	url = {https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/code-quotations},
	abstract = {Learn about F\# code quotations, a language feature that enables you to generate and work with F\# code expressions programmatically.},
	author = {Carter, Phillip},
	urldate = {2021-04-25},
	langid = {english},
	keywords = {feature, quotations},
	file = {Snapshot:/Users/kenneth/Zotero/storage/RIBT2SN5/code-quotations.html:text/html}
}

@inreference{noauthor_mars_2021,
	title = {\textit{Mars Climate Orbiter}},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Mars_Climate_Orbiter&oldid=1016599571},
	abstract = {The Mars Climate Orbiter (formerly the Mars Surveyor '98 Orbiter) was a 638-kilogram (1,407 lb) robotic space probe launched by {NASA} on December 11, 1998 to study the Martian climate, Martian atmosphere, and surface changes and to act as the communications relay in the Mars Surveyor '98 program for Mars Polar Lander. However, on September 23, 1999, communication with the spacecraft was permanently lost as it went into orbital insertion. The spacecraft encountered Mars on a trajectory that brought it too close to the planet, and it was either destroyed in the atmosphere or escaped the planet's vicinity and entered an orbit around the Sun. An investigation attributed the failure to a measurement mismatch between two software systems: metric units by {NASA} and non-metric (imperial or "English") units by spacecraft builder Lockheed Martin.},
	booktitle = {Wikipedia},
	urldate = {2021-04-25},
	date = {2021-04-08},
	langid = {english},
	note = {Page Version {ID}: 1016599571},
	keywords = {mars},
	file = {Snapshot:/Users/kenneth/Zotero/storage/9W985WT4/index.html:text/html}
}

@inreference{noauthor_abstract_2021,
	title = {Abstract syntax tree},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Abstract_syntax_tree&oldid=1016693387},
	abstract = {In computer science, an abstract syntax tree ({AST}), or just syntax tree, is a tree representation of the abstract syntactic structure of source code written in a programming language. Each node of the tree denotes a construct occurring in the source code.
The syntax is "abstract" in the sense that it does not represent every detail appearing in the real syntax, but rather just the structural or content-related details. For instance, grouping parentheses are implicit in the tree structure, so these do not have to be represented as separate nodes. Likewise, a syntactic construct like an if-condition-then expression may be denoted by means of a single node with three branches.
This distinguishes abstract syntax trees from concrete syntax trees, traditionally designated parse trees. Parse trees are typically built by a parser during the source code translation and compiling process. Once built, additional information is added to the {AST} by means of subsequent processing, e.g., contextual analysis.
Abstract syntax trees are also used in program analysis and program transformation systems.},
	booktitle = {Wikipedia},
	urldate = {2021-04-25},
	date = {2021-04-08},
	langid = {english},
	note = {Page Version {ID}: 1016693387},
	keywords = {ast},
	file = {Snapshot:/Users/kenneth/Zotero/storage/PLPRH78K/index.html:text/html}
}

@inreference{noauthor_metaprogramming_2021,
	title = {Metaprogramming},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Metaprogramming&oldid=1017521092},
	abstract = {Metaprogramming is a programming technique in which computer programs have the ability to treat other programs as their data. It means that a program can be designed to read, generate, analyze or transform other programs, and even modify itself while running. In some cases, this allows programmers to minimize the number of lines of code to express a solution, in turn reducing development time. It also allows programs greater flexibility to efficiently handle new situations without recompilation.
Metaprogramming can be used to move computations from run-time to compile-time, to generate code using compile time computations, and to enable self-modifying code. The ability of a programming language to be its own metalanguage is called reflection. Reflection is a valuable language feature to facilitate metaprogramming.
Metaprogramming was popular in the 1970s and 1980s using list processing languages such as {LISP}. {LISP} hardware machines were popular in the 1980s and enabled applications that could process code. They were frequently used for artificial intelligence applications.},
	booktitle = {Wikipedia},
	urldate = {2021-04-25},
	date = {2021-04-13},
	langid = {english},
	note = {Page Version {ID}: 1017521092},
	keywords = {metaprogramming},
	file = {Snapshot:/Users/kenneth/Zotero/storage/FET4NKBJ/index.html:text/html}
}

@online{noauthor_language-integrated_nodate,
	title = {Language-Integrated Quantum Operations: {LIQUi}{\textbar}{\textgreater}},
	url = {https://www.microsoft.com/en-us/research/project/language-integrated-quantum-operations-liqui/},
	shorttitle = {Language-Integrated Quantum Operations},
	abstract = {{LIQUi}{\textbar}{\textgreater} is a software architecture and toolsuite for quantum computing. It includes a programming language, optimization and scheduling algorithms, and quantum simulators. {LIQUi}{\textbar}{\textgreater} can be used to translate a quantum algorithm written in the form of a high-level program into the low-level machine instructions for a quantum device. {LIQUi}{\textbar}{\textgreater} is being developed by the Quantum […]},
	titleaddon = {Microsoft Research},
	urldate = {2021-04-25},
	langid = {american},
	keywords = {liqui},
	file = {Snapshot:/Users/kenneth/Zotero/storage/E5HYD8Y5/language-integrated-quantum-operations-liqui.html:text/html}
}

@article{wecker_liqui_2018,
	title = {{LIQUi}{\textbar}{\textgreater}: A Software Design Architecture and Domain-Specific Language for Quantum Computing},
	url = {https://www.microsoft.com/en-us/research/publication/liqui-a-software-design-architecture-and-domain-specific-language-for-quantum-computing/},
	shorttitle = {{LIQUi}{\textbar}{\textgreater}},
	abstract = {Languages, compilers, and computer-aided design tools will be essential for scalable quantum computing, which promises an exponential leap in our ability to execute complex tasks. {LIQUi}{\textbar}{\textgreater} is a modular software architecture designed to control quantum hardware. It enables easy programming, compilation, and simulation of quantum algorithms and circuits, and is independent of a specific quantum […]},
	author = {Wecker, Dave and Svore, Krysta M. and Svore, Krysta M.},
	urldate = {2021-04-25},
	date = {2018-11-06},
	langid = {american},
	keywords = {liqui},
	file = {Full Text PDF:/Users/kenneth/Zotero/storage/9QFUN9TK/Wecker et al. - 2018 - LIQUi A Software Design Architecture and Domain.pdf:application/pdf;Snapshot:/Users/kenneth/Zotero/storage/6IZ2RTRR/liqui-a-software-design-architecture-and-domain-specific-language-for-quantum-computing.html:text/html}
}

@online{douglas_what_nodate,
	title = {What is {NuGet} and what does it do?},
	url = {https://docs.microsoft.com/en-us/nuget/what-is-nuget},
	abstract = {A comprehensive introduction to what {NuGet} is and does},
	author = {Douglas, Jon},
	urldate = {2021-04-29},
	langid = {english},
	keywords = {nuget},
	file = {Snapshot:/Users/kenneth/Zotero/storage/VFC72Q7V/what-is-nuget.html:text/html}
}

@article{monnier_evolution_2020,
	title = {Evolution of Emacs Lisp},
	volume = {4},
	issn = {2475-1421},
	doi = {10.1145/3386324},
	abstract = {While Emacs proponents largely agree that it is the world's greatest text editor, it is almost as much a Lisp machine disguised as an editor. Indeed, one of its chief appeals is that it is programmable via its own programming language. Emacs Lisp is a Lisp in the classic tradition. In this article, we present the history of this language over its more than 30 years of evolution. Its core has remained remarkably stable since its inception in 1985, in large part to preserve compatibility with the many third-party packages providing a multitude of extensions. Still, Emacs Lisp has evolved and continues to do so.
Important aspects of Emacs Lisp have been shaped by concrete requirements of the editor it supports as well as implementation constraints. These requirements led to the choice of a Lisp dialect as Emacs's language in the first place, specifically its simplicity and dynamic nature: Loading additional Emacs packages or changing the ones in place occurs frequently, and having to restart the editor in order to re-compile or re-link the code would be unacceptable. Fulfilling this requirement in a more static language would have been difficult at best.
One of Lisp's chief characteristics is its malleability through its uniform syntax and the use of macros. This has allowed the language to evolve much more rapidly and substantively than the evolution of its core would suggest, by letting Emacs packages provide new surface syntax alongside new functions. In particular, Emacs Lisp can be customized to look much like Common Lisp, and additional packages provide multiple-dispatch object systems, legible regular expressions, programmable pattern-matching constructs, generalized variables, and more. Still, the core has also evolved, albeit slowly. Most notably, it acquired support for lexical scoping.
The timeline of Emacs Lisp development is closely tied to the projects and people who have shaped it over the years: We document Emacs Lisp history through its predecessors, Mocklisp and {MacLisp}, its early development up to the "Emacs schism" and the fork of Lucid Emacs, the development of {XEmacs}, and the subsequent rennaissance of Emacs development.},
	pages = {1--55},
	issue = {{HOPL}},
	journaltitle = {Proceedings of {ACM} on programming languages},
	author = {Monnier, Stefan and Sperber, Michael},
	date = {2020},
	note = {Publisher: {ACM}},
	keywords = {emacs, History of programming languages ; Lisp ; Emacs Lisp},
	file = {Full Text:/Users/kenneth/Zotero/storage/PXJGUSDD/Monnier and Sperber - 2020 - Evolution of Emacs Lisp.pdf:application/pdf}
}

@article{hickey_history_2020,
	title = {A history of Clojure},
	volume = {4},
	issn = {2475-1421},
	doi = {10.1145/3386321},
	abstract = {Clojure was designed to be a general-purpose, practical functional language, suitable for use by professionals wherever its host language, e.g., Java, would be. Initially designed in 2005 and released in 2007, Clojure is a dialect of Lisp, but is not a direct descendant of any prior Lisp. It complements programming with pure functions of immutable data with concurrency-safe state management constructs that support writing correct multithreaded programs without the complexity of mutex locks.
Clojure is intentionally hosted, in that it compiles to and runs on the runtime of another language, such as the {JVM}. This is more than an implementation strategy; numerous features ensure that programs written in Clojure can leverage and interoperate with the libraries of the host language directly and efficiently.
In spite of combining two (at the time) rather unpopular ideas, functional programming and Lisp, Clojure has since seen adoption in industries as diverse as finance, climate science, retail, databases, analytics, publishing, healthcare, advertising and genomics, and by consultancies and startups worldwide, much to the career-altering surprise of its author.
Most of the ideas in Clojure were not novel, but their combination puts Clojure in a unique spot in language design (functional, hosted, Lisp). This paper recounts the motivation behind the initial development of Clojure and the rationale for various design decisions and language constructs. It then covers its evolution subsequent to release and adoption.},
	pages = {1--46},
	issue = {{HOPL}},
	journaltitle = {Proceedings of {ACM} on programming languages},
	author = {Hickey, Rich},
	date = {2020},
	note = {Publisher: {ACM}},
	keywords = {clojure, Lisp ; Clojure},
	file = {Full Text:/Users/kenneth/Zotero/storage/B5WFIP8B/Hickey - 2020 - A history of Clojure.pdf:application/pdf}
}

@article{macqueen_history_2020,
	title = {The history of Standard {ML}},
	volume = {4},
	issn = {2475-1421},
	doi = {10.1145/3386336},
	abstract = {The {ML} family of strict functional languages, which includes F\#, {OCaml}, and Standard {ML}, evolved from the Meta Language of the {LCF} theorem proving system developed by Robin Milner and his research group at the University of Edinburgh in the 1970s. This paper focuses on the history of Standard {ML}, which plays a central role in this family of languages, as it was the first to include the complete set of features that we now associate with the name "{ML}" (i.e., polymorphic type inference, datatypes with pattern matching, modules, exceptions, and mutable state).
Standard {ML}, and the {ML} family of languages, have had enormous influence on the world of programming language design and theory. {ML} is the foremost exemplar of a functional programming language with strict evaluation (call-by-value) and static typing. The use of parametric polymorphism in its type system, together with the automatic inference of such types, has influenced a wide variety of modern languages (where polymorphism is often referred to as generics ). It has popularized the idea of datatypes with associated case analysis by pattern matching. The module system of Standard {ML} extends the notion of type-level parameterization to large-scale programming with the notion of parametric modules, or functors .
Standard {ML} also set a precedent by being a language whose design included a formal definition with an associated metatheory of mathematical proofs (such as soundness of the type system). A formal definition was one of the explicit goals from the beginning of the project. While some previous languages had rigorous definitions, these definitions were not integral to the design process, and the formal part was limited to the language syntax and possibly dynamic semantics or static semantics, but not both.
The paper covers the early history of {ML}, the subsequent efforts to define a standard {ML} language, and the development of its major features and its formal definition. We also review the impact that the language had on programming-language research.},
	pages = {1--100},
	issue = {{HOPL}},
	journaltitle = {Proceedings of {ACM} on programming languages},
	author = {{MacQueen}, David and Harper, Robert and Reppy, John},
	date = {2020},
	note = {Publisher: {ACM}},
	keywords = {Language design ; Operational semantics ; Standard {ML} ; Type checking, standard ml},
	file = {Full Text:/Users/kenneth/Zotero/storage/F53XLB29/MacQueen et al. - 2020 - The history of Standard ML.pdf:application/pdf}
}

@article{steele_evolution_1993,
	title = {The evolution of Lisp},
	volume = {28},
	issn = {0362-1340},
	doi = {10.1145/155360.155373},
	abstract = {Lisp is the world's greatest programming language—or so its proponents think. The structure of Lisp makes it easy to extend the language or even to implement entirely new dialects without starting from scratch. Overall, the evolution of Lisp has been guided more by institutional rivalry, one-upsmanship, and the glee born of technical cleverness that is characteristic of the “hacker culture” than by sober assessments of technical requirements. Nevertheless this process has eventually produced both an industrial-strength programming language, messy but powerful, and a technically pure dialect, small but powerful, that is suitable for use by programming-language theoreticians. We pick up where {McCarthy}'s paper in the first {HOPL} conference left off. We trace the development chronologically from the era of the {PDP}-6, through the heyday of Interlisp and {MacLisp}, past the ascension and decline of special purpose Lisp machines, to the present era of standardization activities. We then examine the technical evolution of a few representative language features, including both some notable successes and some notable failures, that illuminate design issues that distinguish Lisp from other programming languages. We also discuss the use of Lisp as a laboratory for designing other programming languages. We conclude with some reflections on the forces that have driven the evolution of Lisp.},
	pages = {231--270},
	number = {3},
	journaltitle = {{SIGPLAN} notices},
	author = {Steele, Guy L. and Gabriel, Richard P.},
	date = {1993},
	keywords = {lisp}
}

@article{mccarthy_history_1978,
	title = {History of {LISP}},
	volume = {13},
	issn = {0362-1340},
	doi = {10.1145/960118.808387},
	abstract = {This paper concentrates on the development of the basic ideas and distinguishes two periods - Summer 1958 through Summer 1958 when most of the key ideas were developed (some of which were implemented in the {FORTRAN} based {FLPL}), and Fall 1958 through 1962 when the programming language was implemented and applied to problems of artificial intelligence. After 1962, the development of {LISP} became multi-stranded, and different ideas were pursued in different places.},
	pages = {217--223},
	number = {8},
	journaltitle = {{SIGPLAN} notices},
	author = {{McCarthy}, John},
	date = {1978},
	note = {Publisher: {ACM}},
	keywords = {History of {LISP}}
}